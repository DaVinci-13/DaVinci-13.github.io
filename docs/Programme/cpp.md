---
title: Primer C++
layout: doc
date:   2023-04-09 15:20:00 +0800
categories: C++
---

# I C++基础
## 1 开始
## 2 变量与基本类型
### 1. 基本内置类型
arithmetric type 算术类型  
1. 整型：
	- 字符和bool
	- 其他整型：带符号 signed、无符号 unsigned
2. 浮点型： 单精度值、双精度值、扩展精度值

convert 类型转换：  
建议：避免无法预知和依赖实验环境的行为。因为编译器无须（有时是不能）检测错误也能正常运行。  
提示：*切勿混用带符号和无符号性。*  

literal 字面值常量
- 整形字面值：十进制、八进制（以0开头）、十六进制（以0x开头）
- 浮点字面值：小数、科学计数法
- 字符和字符串字面值
- 转义序列 escape sequence
- 指定字面值的类型
- 布尔字面值：true/false
- 指针字面值：nullptr

### 2. variable 变量
	- 变量定义（definition）
		- 对于C++:变量可以互换对象
		    - object，对象，一块能存储数据并具有某种类型的内存空间。
		    - value，值，只读的数据。
		- type specifer 类型说明符：（类型）关键字
		- 初始化（initialized，创建变量时赋予一个初始值）与赋值（擦出当前值，以新值替代）		
	
	- **external**，声明declaration）而非定义

### 3. compound type 复合类型

    1. 引用（reference）：别名，给一个以存在的对象起了另一个名字。
        - 本质：间接访问。
        - 把引用和初始值对象做绑定
        - 定义时必须被初始化
        - 初始值必须是一个对象
        - 引用与初始值必须同类型
        - 初始化后无法改变引用对象
        - 无法定义引用的引用
 
    2. pointer 指针
        - 本质：简介访问
	    - 与引用的不同：
	        1. 本身就是对象，允许对指针赋值和拷贝，
            2. 在生命周期内可以先后指向多个不同的对象。 
            3. 无须在定义时赋值。若未被初始化，则有一个不确定的值。
        - 特性：
            - 指针类型与指向对象类型必须严格匹配。（两种情况除外）
        - 符号： 
            - \* : 解引用（*）（指针必须已经初始化）。
            - &
        - 指针的4种状态
            1. 指向一个对象；
            2. 指向紧邻对象所占空间的下一个位置。常见于循环/迭代中；
            3. 空指针，*nullptr*，指针没有指向任何对象，未被初始化。
                - e.g.  ``int *p = nullptr``；
                - `NULL`是预处理变量（preprocessor variable），值为0
            4. 无效指针：上述情况之外的其他所有值。e.g.指向数组中不存在的元素。
        - 指针和赋值：赋值永远改变的是等号左侧的对象。
        - 其他指针操作：条件、比较
        - void*指针：**可以存放任意对象的地址。无法确定地址的对象类型**。

### 4. const限定符
#### 0. 
        - const对象必须初始化
		- 使用**external**关键字在多文件共享const对象

#### 1. 对常量的引用（reference to const）
        - 常量对象只能使用常量引用来引用
        - 初始化常量引用时可以使用临时量（temporary）对象
            - 临时量：当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象。
        - 常量引用可能引用一个非const对象：此时不允许常量引用修改它的值，但允许通过其他途径修改。
    
#### 2. 常量指针（pointer to const）
        - 常量对象只能使用常量指针来指向
        - const指针
        - **待续**

#### 3. 顶层const（top-level const）
        - 顶层const：指针本身是个常量。
        - 底层const：指针指向的对象是常量，可以改变指针的值。
        - 靠右的const是顶层const，靠左的是底层const。
            - ``int const *p1``
            - ``const int *p2``
        - 拷贝：**待续**

#### 4. 常量表达式（const expression）
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。  
e.g. 字面值、用常量表达式初始化的const对象。

##### constexpr变量  
允许将变量声明为constexpr类型由编译器验证变量是否为常量表达式。  
声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。     

##### 字面值类型：声明constexpr时用到的类型
e.g. 算术类型、引用和指针  
函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量；相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。  
特别的，允许函数定义一类有效范围超出函数体本身的变量，这类变量一样也有固定地址，因此能被constexpr指向和引用。  
指针和constexpr：如果constexpr声明中定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。
	
### 5. 处理类型

#### 1. 类型别名（type alias）
两种方法：typedef、using
		
#### 2. auto：编译器通过初始值推算变量类型
		
#### 3. decltype：选择并返回操作数(结果)的数据类型
 **注意**：对于decltype的表达式来说，如果变量名加上了以对括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。切记：decltype((*variable*))的结果永远是引用。

### 6. 自定义数据类型
预处理器（preprocessor）：确保头文件多次包含仍能安全工作的常用技术。  
头文件保护符（header guard）：依赖于预处理变量（`#define`、`#ifdef`、`#ifndef`、`#endif`），作用是防止重复包含。

## 3 字符串、向量和数组
### 1. 命名空间的using声明

### 2. 标注库类型string
#### 1. 定义和初始化string对象： 
直接初始化（``string s("hiya");``）和拷贝初始化(``string s="hiya";``)的区别是是否使用等号（=）。
#### 2. string对象上的操作：
读写、size函数与`string::size_type`类型、比较、赋值、相加
#### 3. 处理string对象值中的字符

### 3. 标注库类型vector
#### 1. 定义和初始化vector对象：
值初始化（value-initialized，使用小括号）；  
列表初始化（list-initialized，使用中括号）。
#### 2. 向vector对象中添加元素
#### 3. 其他vector操作：
**注意**，ector对象的下标运算符可用于访问已存在的元素，而不能用于添加元素。

### 4. 迭代器（iterator）
#### 1. 使用迭代器
#### 2. 迭代器运算（iterator arithmetic）
迭代器的距离：类型是`difference_type`的到符号整数

### 5. 数组
#### 1. 定义和初始化内置数组：
（与vector不同）大小固定不变，不允许数组间的拷贝和赋值。
#### 2. 访问数组元素
#### 3. 指针和数组：标准库函数begin和end
#### 4. C风格字符串
#### 5. 与旧代码的接口：使用数组初始化vector对象
#### 6. 多维数组

## 4 表达式
### 1. 基础
#### 1. 基本概念
##### 组合运算符和运算对象
运算符优先级  
##### 运算对象转换
里氏转换  
##### 重载运算符（overloaded operator）  
##### **左值和右值**
- 左值可以位于赋值语句的左侧，右值则不能。
- 当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时候，用的是对象的身份（在内存中的位置）。
- （重要）原则：在需要右值的地方可以用左值来代替，但是不能把右值当值使用。

**待续**
#### 2. 优先级和结合律
#### 3. 求值顺序
### 2. 算术运算符
### 3. 逻辑和关系运算符
### 4. 赋值运算符
### 5. 递增和递减运算符
### 6. 成员访问运算符：”.“、“->”
### 7. 条件运算符/三目运算符
### 8. 位运算符
### 9. sizeof运算符
### 10. 逗号运算符
### 11. 类型转换
#### 1. 算术转换（arithmetic conversion）
#### 2. 其他隐式转换
#### 3. **显示转换**：
强制类型转换（cast）  
##### static_cast
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast.  
使用：
1. 把一个较大的算术类型赋给较小的类型
2. 编译器无法自动执行的类型转换
##### dynamic_cast
支持运行时类型识别。
##### const_cast
“去掉const性质（cast away the const）”，将常量对象转换成非常量对象。
特点：  
1. 只能改变运算对象的底层const；
2. 只能改变表达式的常量属性，不能改变表达式的类型。
##### reinterpret_cast
通常为运算对象的位模式提供较低层次上的重新解释。
虽然经过了重新解释，但本质上为发生变化，使用就可能运行时发生错误。
**非常危险**：其中的关键问题是类型改变了，但比哦安一起没有给出任何警告或者错误的提示信息。
**WARNNING**：本质上依赖于及其。要想安全的使用，就必须对涉及的类型和编译器实现转换的过程都非常了解。
##### 建议：避免强制类型转换
##### 旧式的强制类型转换
包含：函数形式的强制类型转换、C语言风格的强制类型转换。

### 12. 运算符优先级表

## 5 语句
### 1. 简单语句
表达式语句（expression statement）：执行表达式并丢弃掉求值结果。  
空语句（null statement）
复合语句（compound statement）：也叫块（block）。

### 2. 语句作用域

### 3. 条件结构
#### 1. if语句
#### 2. switch语句

### 4. 迭代语句
#### 1. while语句
#### 2. 传统的for语句
#### 3. 范围for语句
#### 4. do while语句

### 5. 跳转语句
#### 1. break语句
#### 2. continue语句
#### 3. goto语句
#### 4. return语句

### 6. try语句块和异常处理
#### 1. throw表达式
#### 2. try语句块
鲁棒性
#### 3. 标准异常
C++标准库的异常类的头文件：
- exception头文件:定义了最通用的异常类exception，只报告异常的发生，不提供任何额外信息。
- stdexcept头文件：定义了几种常用的异常类。
    - exception：最常见的问题
    - runtime_error：只有在运行时才能检测出的问题
    - range_error：运行时错误，生成的结果超出了有意义的值域范围。
    - overflow_error：运行时错误，计算上溢。
    - underflow_error：运行时错误，计算下溢。
    - logic_error：程序逻辑错误。
    - domain_error：逻辑错误，参数对用的结果值不存在。
    - invalid_error：逻辑错误，无效参数。
    - length_error：逻辑错误，试图创建一个超出该类型最大长度的对象。
    - out_of_range：逻辑错误，使用一个超出有效范围的值。
- new头文件：定义了bad_alloc异常类型。
- type_info头文件：定义了bad_cast异常类型。

what()函数：异常类型的唯一成员函数，返回值是一个指向C风格字符串的`const char *`，目的是提供关于异常的一些文本信息。

## 6 函数
### 1. 函数基础
函数（function）：返回类型（return type）、函数名、形参（parameter）列表以及函数体（function body）。  
调用运算符（call operator）：实参（argument）
#### 1. 局部对象
生命周期（lifetime）  
局部变量（local variable）,隐藏同名  
局部静态对象（local static object）

#### 2. 函数声明/函数原型（function prototype）
建议在头文件中进行函数声明

#### 3. 分离式编译（separate compilation）

### 2. 参数传递
引用传递（passed by reference）或者传引用调用（called by reference）
值传递（passed by alue）或者传值调用（called by value）

#### 1. 传值参数
#### 2. 传引用参数
避免拷贝
返回额外信息
#### 3. const形参和实参
指针或引用形参与const：**待续**  
尽量使用常量引用
#### 4. 数组形参
#### 5. main：处理命令选项
可以通过命令行向程序传递两个（可选的）形参给main函数。
```cpp
int main(int argc, char *argv[]){ return 0; }
```
第二个形参argv是一个指向C风格字符串数组的指针；第一个元素是数组中字符串的数量。   
main函数也可定义成：
```cpp
int main(int argc, char **argv){ return 0; }
```
#### 6. 含有可变形参的函数
##### initializer_list形参
标准库类型，用于存储某种特定类型的值的数组。  
情况：实参数量未知但是全部实参的类型都相同。  
```cpp
void error_msg(intializer_list<string> i1)
{
    for (auto beg = i1.begin(); beg != i1.end(); ++beg)
        cout<< *beg << " ";
    cout << endl;
}
```
##### 省略符形参
```cpp
void foo(param_list,...);
```
##### 可变参数模板
**待续**

### 3. 返回类型和return语句
#### 1. 无返回值函数
#### 2. 有返回值函数
- 函数指针
- 引用返回左值
#### 3. 返回数组指针
##### 指针函数
##### 使用尾置返回类型（trailing return tyoe）
```cpp
auto func(int i) -> int(*)[10];
```
##### 使用decltype
```cpp
int odd[]={1,3,5,7,9};
decltype(odd) *arrPtr(int i)
{
    return &odd;
}
```
### 4. 函数重载
##### 重载和const形参
有无顶层const形参在函数重载中无法区分。
##### const_cast和重载
const_cast在重载函数的场景中最有用。
##### 调用重载的函数
函数匹配（function matching）：最佳匹配（best match）、无匹配（no match）、二义性调用（ambiguous call）  
重载确定（overload resolution）

### 5. 特殊用途语言特性
#### 1. 默认实参（default argument）
默认实参只能在参数列表的尾部
#### 2. 内联函数（inline）和constexpr函数
内联函数可避免函数调用的开销：将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。  
很多编译器不支持内链递归函数。  
constexpr函数是指能用于常量表达式的函数。函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。  
内联函数和constexpr函数通常被定义在头文件内。
#### 3. 调试帮助
##### assert预处理宏（preprocessor marco）
```cpp
asset(expr);
```
首先对*expr*求值，如果表达式为假（即0），assert输出信息并终止程序的执行。
##### NDEBUG预处理变量
定义NDEBUG则assert则不会执行运行时检查。

### 6. 函数匹配
确定候选函数（candidate function）:1.同名；2.声明在调用点可见。  
可行函数（viable function）：1.形参数量与实参相等；2.实参类型与对应形参类型相同，或者可以实参类型转换。
寻找最佳匹配
含有多个形参的函数匹配：二义性调用。  

### 7. 函数指针
函数指针指向的是函数而非对象。
##### 使用函数指针
##### 重载函数的指针
##### 函数指针形参
形参可以是指向函数的指针.
##### 返回指向函数的指针
##### 将auto和decltype用于函数指针类型

## 7 类
### 1. 定义抽象数据类型(abstract data type)
- 成员函数
- 构造函数（constructor）
- 拷贝、赋值和析构
- 接口(interface)和实现(implementation)

### 2. 访问控制和封装（encapsulation）
访问说明符（access specifiers）：*private*、*public*
##### 使用class和struct关键字
唯一区别：struct的默认访问权限是public，而class则是private。

#### 1. 友元（friend）
类可以允许其他类或者函数访问它的非公有成员。  
友元声明只能出现在类定义的内部，但是具体位置不限。  
友元不是类的成员，也不受所在区域的访问控制级别的约束。  

### 3. 类的其他特性
#### 1. 成员
可变数据成员（mutable data member）：即使在const成员函数中也可以改变一个可变成员的值。  

#### 2. 返回*this的成员函数
建议：对于公共代码使用私有功能函数。

#### 3. 类类型
前向声明（forward declaration）：仅声明类而暂时不定义，此时该类是一个不完全类型（incomplete type）。

#### 4. 友元
##### 类之间的友元关系：友元类
##### 令成员函数作为友元
必须明确指出该成员函数属于哪个类。
##### 函数重载和友元
需要对函数重载的一组函数中的每一个分别声明友元。
##### 友元声明和作用域
```cpp
struct X{
    friend void f() {}
    void h();
};
void f();
void X::h()
{
    return f();
}
```

### 4. 类的作用域
#### 1. 名字查找与类的作用于
名字查找（name lookup）：寻找与所用名字最匹配的声明的过程。

### 5. 构造函数再探
#### 1. 构造函数初始值列表
构造函数的初始值有时必不可少。
成员初始化的顺序：与在类定义中的出现顺序一致。最好尽量避免使用某些成员初始化其他成员。

#### 2. 委托构造函数（delegating constructor）
一个委托构造函数使用它所属类的其他构造函数执行它的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。

#### 3. 默认构造函数的作用

#### 4. 隐式的类类型转换
类类型转换只允许一步。  
类类型转换不是总有效。  
抑制构造函数定义的隐式转换：在类内声明构造函数时使用**explicit**。只对一个实参的构造函数有效，多个实参的构造函数不能用于执行隐式转换，所以无需explicit。  
explicit构造函数只能用于直接初始化。  
为转换显式地使用构造函数。  
标准库中含有显式构造函数的类：
- 接受一个单参数的``const char*``的string构造函数不是explicit的。
- 接受一个容量参数的vector构造函数是explicit的。  

#### 5. 聚合类（aggregate class）
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。  
当一个类满足如下条件时，我们说它是聚合的：
- 所有成员都是public的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有virtual函数。
显式地初始化类的对象的成员存在三个明显的缺点：
- 要求类的所有成员都是public的。
- 将正确初始化每个对象的每个成员的重任交给类用户（而非作者）。
- 添加或删除一个成员之后，所有的初始化语句都需要更新。

#### 6. 字面值常量类
字面值常量类的要求：
- 数据成员都必须是字面值类型。
- 类必须至少含有一个constexpr构造函数。
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的默认定义。  
constexpr构造函数：必须初始化所有数据成员，初始值或者使用constexpr后遭函数，或者是一条常量表达式。

### 6. 类的静态成员
声明：``static``关键字。  
使用：使用作用域运算符直接访问静态成员。  
定义：`static`关键字值出现在类内部的声明语句。  
初始化：通常情况下，类的静态成员不应该在类的内部初始化。  
静态成员能用于某些场景，而普通成员不能。  

# II C++标准库
## 8 IO库
### 1. IO类
IO库类型和头文件：
| 头文件 | 类型 | 类型（支持宽字符） | 功能 |
|----|----|----|----|
| iostream | istream | wistream | 从流读取数据 |
|  | ostream | wostream | 向流写入数据 |
|  | iostream | wiostream | 读写流 |
| fstream | ifstream | wifstream | 从文件读取数据 |
|  | ofstream | wofstream | 向文件写入数据 |
|  | iosftream | wiofstream | 读写文件 |
| sstream | istringstream | wistringstream | 从string读取数据 |
|  | ostringstream | wostringstream | 向string写入数据 |
|  | stringstream | wstringstream | 读写string |

IO类型间的关系：ifstream和istringstream继承自istream。  
标准库是我们能忽略这些不同类型的流之间的差异，这是通过继承机制（inheritance）实现的。
e.g. 我们可以用`>>`读取数据，而不用关是从一个控制台窗口，一个磁盘文件，还是一个string读取。

#### 1. IO对象无拷贝和赋值

#### 2. 条件状态（condition state）
IO操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。因此IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。  
由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单法哪个法是将它当作一个条件来使用。

### 2. 文件输入输出

### 3. string流