---
title: CLR via C#
layout: doc
date:   2023-04-09 15:20:00 +0800
categories: C#, CLR
---

# CLR via C#

### CLR基础

1. CLR的执行模型
	- 内存管理、加载、编译、安全、异常处理、线程同步
	- 编译：源代码文件->（JIT）编译器->托管模块（IL+元数据）
	- 流程：类库>程序集>托管模块（PE32+头 + CLR头 + IL + 源数据）
	- 通用类型系统CTS,Common Type System
		- 字段+方法+属性+事件
		- 封装：访问修饰符
	- 公共语言规范，CLS，Common Language Specification
	- 与非托管交互
		- 托管代码通过DLL调用非托管函数
		- 托管代码使用非托管COM（Component Object Model）组件（服务器）
		- 非托管代码可以使用托管类型（服务器）

2. .Net Framework --生成、打包、部署和管理应用程序及类型
	- windows应用存在的问题
		- dll hell：一个PE会依赖其他的dll
		- 安装：目录+注册表
		- 安全：悄悄下载
	- 将类型生成到模块中
		- 编译器参考程序集和响应文件将源代码生成PE
		- PE运行时查找响应文件加载程序集
	- 元数据=定义表+引用表+清单表
	- 将模块合并成程序集
		- 调用：CLR->程序集->文件
		- 程序集
			- 可重用（多编程语言实现）类型的基本单元
			- 使用版本号标记，可增量更新
			- 关联安全信息
				- 应用程序通过codeBase指定程序集
				- 将资源与数据文件单独划分
		- 不包含清单表的PE必须加载到另一程序集中使用
	- 程序集版本信息
	- 语言文化
	- 私有部署的程序集
		- PE基目录及子目录
		- 检查防篡改造成性能开销
	- 简单管理控制
		- XML配置文件

3. 共享程序集和强命名程序集
	- 部署与命名
		- 全局部署
			- 公认位置的程序集
	- 强命名程序集
		- 发布者签名，唯一标识
			- 文件名（不计扩展名）+版本号+语言文化+公钥
		- 防篡改
	- 全局程序集缓存，Global Assembly Cache，GAC
	- 延迟签名（delayed signing）/部分签名（partial signing）
		- 开发阶段使用公钥签名生成程序集，之后使CLR暂时信任不做哈希处理，但会失去保护
		- 打包部署使用私钥签名
	- 私有部署强命名程序集
	- 解析
		- 解析路线：CLR->MethodRef->IL->JIT编译->本机代码
		- 解析地址
			- 早期绑定：相同文件
			- 不同文件、相同程序集
			- 不同文件、不同程序集
	- 高级管理控制（配置）
		- 发布者策略控制

4. 类型基础
	- Object
		- 最终基类
		- new
			- 创建
				- 计算类型及所有基类型定义字段所需要的字节数
				- 创建管理对象的额外成员
					- 类型对象指针 type object pointer
					- 同步块索引 sync block index
				- 初始化额外成员
				- 调用实例构造器
		- 类型转换
			- 里氏转换
			- 强转
				- is
				- as
		- namespace
		- 运行交互：栈+递归
			- 1个线程分配1MB的栈
			- prologue和epilogue

5. 基元类型、引用类型、值类型
	- 基元类型
		- glossary
			- 直接支持
			- 映射到Framework类库FCL
			- e.g.
				- int=System.Int32
		- 类型转换与溢出检查
			- checked和unchecked
			- CLR的数据转换IL指令
	- glossary
		- 内存必须congo托管堆分配
		- 堆上分配的每个对象必须有类型对象指针和同步索引块
		- 对象中的其他字节总是初始化为0
		- 从托管堆分配对象，内存不足时会强制执行垃圾回收
	- 值类型
		- 具有基元类型的行为，十分简单的类型
		- 无继承关系
		- 类型实例大小
			- 16字节以下
			- 16字节以上但不传参
		- 拆装箱
			- 装箱
				- 在托管堆中分配内存（递归内存+额外成员（类型对象指针+同步索引块））
				- 值类型字段复制到新分配的堆内存
				- 返回对象地址
			- 拆箱
				- 获取已装箱实例的未装箱部分的指针
				- 拆箱之后才紧接着进行内存复制
	- 值类型和引用类型
		- 区别
			- 表示形式：未装箱/已装箱
			- 父类
			- 初始值
			- 传参
			- 拷贝
			- 回收
				- 引用：垃圾回收
				- 值：方法不再活动即被释放
		- 比较：==和equal
		- GetHashcode
	- dynamic基元类型
		- 可用于局部遍历、字段和参数。
		- 在生成IL代码阶段才推断类型
		- dynamic和var的区别
			- var是语法糖，需要编辑器推断类型，并且不兼容表达式

6. 类型和成员基础
	- 成员
		- 常量、字段、实例构造器、类型构造器、方法、操作符重载、转换操作符、属性、事件、类型
	- 可见性
		- 友元程序集
			- [assembly:InternalVisibleTo["**********"]]Internal sealed class XXXType {...}
	- 静态类
		- 必须继承至Ststem.Object
		- 不能实现任何接口
		- 只能定义静态成员
		- 不能作为实例的变量使用
	- 分部类、结构和接口
		- 分部类
			- 源代码控制
			- 在同一个文件中将类或结构分解成不同的逻辑单元
			- 代码拆分
	- 组件、多态和版本控制
		- 组件软件编程，Component Software Programming， CSP
		- 组件的特点
			- .Net Framework：组件=程序集
			- 强命名
			- 程序集的代码永远不会静态链接到另一程序集中：.Net总是使用动态链接（组件永远维护自己的（强命名）标识）
			- 组件必须有引用元数据表
			- 组件必须指定他需要的安全权限
			- 组件要发布任何版本都不会改变的接口
		- 虚方法
			- Call/Callvirt 指令调用
		- 密封类

7. 常量和字段
	- 常量
		- 基元类型
		- C#：非基元类型的null
	- 字段
		- 类型字段的容纳数据需要的动态内存是在内存对象中分配的
		- 类型对象是在类型加载到一个AppDomain时创建的
		- 首次进行JIT编译时才将类型加载到一个AppDomain
		- readonly只能在构造器方法写入
			- 编译器和验证机制
			- 可利用反射修改
			- readonly引用类型时，不可改变的是引用，而不是引用的对象
		- 内联初始化：在代码中直接赋值来初始化，而不是将对构造器的调用写出来


8. 方法
	- 实例构造器和类（引用类型）
		- 在方法元数据表中始终叫.ctor
		- 禁止在构造器中调用虚方法，因为会执行派生类对虚方法的实现
		- 编译器在调用基类构造器前使用简化语法对所有字段进行初始化
	- 实例构造器和结构（值类型）
		- 结构不允许显式定义无参构造
		- 结构不能有实例字段初始值
		- 在控制返回到调用方之前，字段必须全部赋值
	- 类型构造器

9. 参数

10. 属性

11. 事件

12. 泛型
    1. 
    2. 
        1. 
        2. 
        3. 
        4. 代码爆炸

### 设计类型

### via C#

