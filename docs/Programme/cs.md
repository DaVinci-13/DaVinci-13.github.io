---
title: CLR via C#
layout: doc
date:   2023-04-09 15:20:00 +0800
categories: C#, CLR
---

# CLR via C#

## CLR基础

1. CLR的执行模型
	- 内存管理、加载、编译、安全、异常处理、线程同步
	- 编译：源代码文件->（JIT）编译器->托管模块（IL+元数据）
	- 流程：类库>程序集>托管模块（PE32+头 + CLR头 + IL + 源数据）
	- 通用类型系统CTS,Common Type System
		- 字段+方法+属性+事件
		- 封装：访问修饰符
	- 公共语言规范，CLS，Common Language Specification
	- 与非托管交互
		- 托管代码通过DLL调用非托管函数
		- 托管代码使用非托管COM（Component Object Model）组件（服务器）
		- 非托管代码可以使用托管类型（服务器）

2. .Net Framework --生成、打包、部署和管理应用程序及类型
	- windows应用存在的问题
		- dll hell：一个PE会依赖其他的dll
		- 安装：目录+注册表
		- 安全：悄悄下载
	- 将类型生成到模块中
		- 编译器参考程序集和响应文件将源代码生成PE
		- PE运行时查找响应文件加载程序集
	- 元数据=定义表+引用表+清单表
	- 将模块合并成程序集
		- 调用：CLR->程序集->文件
		- 程序集
			- 可重用（多编程语言实现）类型的基本单元
			- 使用版本号标记，可增量更新
			- 关联安全信息
				- 应用程序通过codeBase指定程序集
				- 将资源与数据文件单独划分
		- 不包含清单表的PE必须加载到另一程序集中使用
	- 程序集版本信息
	- 语言文化
	- 私有部署的程序集
		- PE基目录及子目录
		- 检查防篡改造成性能开销
	- 简单管理控制
		- XML配置文件

3. 共享程序集和强命名程序集
	- 部署与命名
		- 全局部署
			- 公认位置的程序集
	- 强命名程序集
		- 发布者签名，唯一标识
			- 文件名（不计扩展名）+版本号+语言文化+公钥
		- 防篡改
	- 全局程序集缓存，Global Assembly Cache，GAC
	- 延迟签名（delayed signing）/部分签名（partial signing）
		- 开发阶段使用公钥签名生成程序集，之后使CLR暂时信任不做哈希处理，但会失去保护
		- 打包部署使用私钥签名
	- 私有部署强命名程序集
	- 解析
		- 解析路线：CLR->MethodRef->IL->JIT编译->本机代码
		- 解析地址
			- 早期绑定：相同文件
			- 不同文件、相同程序集
			- 不同文件、不同程序集
	- 高级管理控制（配置）
		- 发布者策略控制

## 设计类型
4. 类型基础
	- Object
		- 最终基类
		- new
			- 创建
				- 计算类型及所有基类型定义字段所需要的字节数
				- 创建管理对象的额外成员
					- 类型对象指针 type object pointer
					- 同步块索引 sync block index
				- 初始化额外成员
				- 调用实例构造器
		- 类型转换
			- 里氏转换
			- 强转
				- is
				- as
		- namespace
		- 运行交互：栈+递归
			- 1个线程分配1MB的栈
			- prologue和epilogue

5. 基元类型、引用类型、值类型
	- 基元类型
		- glossary
			- 直接支持
			- 映射到Framework类库FCL
			- e.g.
				- int=System.Int32
		- 类型转换与溢出检查
			- checked和unchecked
			- CLR的数据转换IL指令
	- glossary
		- 内存必须congo托管堆分配
		- 堆上分配的每个对象必须有类型对象指针和同步索引块
		- 对象中的其他字节总是初始化为0
		- 从托管堆分配对象，内存不足时会强制执行垃圾回收
	- 值类型
		- 具有基元类型的行为，十分简单的类型
		- 无继承关系
		- 类型实例大小
			- 16字节以下
			- 16字节以上但不传参
		- 拆装箱
			- 装箱
				- 在托管堆中分配内存（递归内存+额外成员（类型对象指针+同步索引块））
				- 值类型字段复制到新分配的堆内存
				- 返回对象地址
			- 拆箱
				- 获取已装箱实例的未装箱部分的指针
				- 拆箱之后才紧接着进行内存复制
	- 值类型和引用类型
		- 区别
			- 表示形式：未装箱/已装箱
			- 父类
			- 初始值
			- 传参
			- 拷贝
			- 回收
				- 引用：垃圾回收
				- 值：方法不再活动即被释放
		- 比较：==和equal
		- GetHashcode
	- dynamic基元类型
		- 可用于局部遍历、字段和参数。
		- 在生成IL代码阶段才推断类型
		- dynamic和var的区别
			- var是语法糖，需要编辑器推断类型，并且不兼容表达式

6. 类型和成员基础
	- 成员
		- 常量、字段、实例构造器、类型构造器、方法、操作符重载、转换操作符、属性、事件、类型
	- 可见性
		- 友元程序集
			- [assembly:InternalVisibleTo["**********"]]Internal sealed class XXXType {...}
	- 静态类
		- 必须继承至Ststem.Object
		- 不能实现任何接口
		- 只能定义静态成员
		- 不能作为实例的变量使用
	- 分部类、结构和接口
		- 分部类
			- 源代码控制
			- 在同一个文件中将类或结构分解成不同的逻辑单元
			- 代码拆分
	- 组件、多态和版本控制
		- 组件软件编程，Component Software Programming， CSP
		- 组件的特点
			- .Net Framework：组件=程序集
			- 强命名
			- 程序集的代码永远不会静态链接到另一程序集中：.Net总是使用动态链接（组件永远维护自己的（强命名）标识）
			- 组件必须有引用元数据表
			- 组件必须指定他需要的安全权限
			- 组件要发布任何版本都不会改变的接口
		- 虚方法
			- Call/Callvirt 指令调用
		- 密封类

7. 常量和字段
	- 常量
		- 基元类型
		- C#：非基元类型的null
	- 字段
		- 类型字段的容纳数据需要的动态内存是在内存对象中分配的
		- 类型对象是在类型加载到一个AppDomain时创建的
		- 首次进行JIT编译时才将类型加载到一个AppDomain
		- readonly只能在构造器方法写入
			- 编译器和验证机制
			- 可利用反射修改
			- readonly引用类型时，不可改变的是引用，而不是引用的对象
		- 内联初始化：在代码中直接赋值来初始化，而不是将对构造器的调用写出来


8. 方法
	- 实例构造器和类（引用类型）
		- 在方法元数据表中始终叫.ctor
		- 禁止在构造器中调用虚方法，因为会执行派生类对虚方法的实现
		- 编译器在调用基类构造器前使用简化语法对所有字段进行初始化
	- 实例构造器和结构（值类型）
		- 结构不允许显式定义无参构造
		- 结构不能有实例字段初始值
		- 在控制返回到调用方之前，字段必须全部赋值
	- 类型构造器

9. 参数

10. 属性

11. 事件

12. 泛型
    1. 
    2. 
        1. 
        2. 
        3. 
        4. 代码爆炸
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 可验证性和约束
        约束：where
        无法重写类型参数
        1. 主要约束：0-1
        - class
        - struct
        2. 次要约束：0-？
        - 接口
        - 类型参数约束/裸类型约束：制定的类型实参要么就是约束的类型，要么就是约束的类型的派生类。
        3. 构造器约束：0-1
        4. 其他可验证问题
        - 泛型类型变量的转型
        - 将泛型类型变量设为默认值
            default(T)
        - 将泛型类型变量与null进行比较
        - 两个泛型类型遍历相互比较
        - 泛型类型变量作为操作数使用

13. 接口
    1. 类和接口继承
    2. 定义接口
    3. 继承接口
    4. 关于调用接口方法的更多讨论
    5. 隐式和显示接口方法实现
    6. 泛型接口
    7. 泛型和接口约束
    8. 实现多个具有相同方法名和签名的接口
    9. 用 显式接口方法(EIMI) 实现来增强编译时类型安全性
    10. 谨慎使用显示接口方法实现
    11. 设计：基类还是接口

## 基本类型
14. 字符、字符串和文本处理
    1. 字符
        - .NET Framework: 16bit Unicode
        - System.Char
    2. System.String  
        不可变（immutable）的顺序字符集，继承于Object
        1. 构造字符串
            - 基元类型
            - Idstr(load string)指令:CLR用一种特殊方式构造字面值String对象
            - unsafe
            - 转义机制
            - GC：
                - 字面值String在编译时连接，最终只有一个字符串放入模块元数据
                - 非字面值String使用 +操作符 ，连接时在运行时进行，在堆上创建多个String对象，需要垃圾会说，对性能有影响
            - 逐字字符串(verbatim string)：引号之间的所有字符会都被视为字符串的一部分
                - @
                - 通常用于制定文件和目录的路径
                - 与正则表达式搭配使用
        2. 字符串是不可变的
            - GC：
                - String类的字符串操作会在对上创建大量的String对象，造成更频繁的垃圾回收，从而影响性能。
                - StringBuilder,高效执行大量字符串操作
            - 不会发生线程同步问题
            - 字符串留用（string interning）：CLR可通过一个String对象共享多个完全一致的String内容，这样能减少系统中的自服从数量，从而节省内存
            - String和CLR紧密集成，出于对性能呢个考虑，String类是密封类
        3. 比较字符串 - 语言文化
        4. 字符串留用
            - 显式调用：String。Interrn
            - 标志
                - System.Runtime.CompilerServices.CompilationRelaxationsAttribute
                - System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning
            - CLR内部可能对某些字符串进行留用，但不要依赖于CLR的这个行为（CLR版本不同行为不同）
            - 字符串留用虽然有用，但留用本身操作需要花时间，所以使用必须谨慎
        5. 字符串池：编译器只在模块的元数据中的字面值字符串值写入一次。引用该字符串的所有代码都被修改成引用元数据中的统一字符串。
        6. 检查字符串中的字符和文本元素 -  StringInfo
        7. 其他字符串操作
    3. 高效率构造字符串 - StringBuilder
        1. 构造StringBuilder对象
            - 最大容量：Intel.MaxValue
            - 容量：默认16,动态扩容（倍增，复制到新数组，原始数组可以被垃圾回收）
            - 字符数组：
        2. StringBuilder的成员
            - 分配新对象的两种情况：
                - 动态构造字符串其长度超过了设置的容量
                - 调用ToString方法
            - 缺点：不方便、效率低
    4. 获取对象的字符串表示：ToString  
        定义类型时总应该重写ToString方法
        1. 制定具体的格式和语言文化
            - 实现System.IFormattable接口
            - 实现System.IFormatProvider接口
        2. 将多个对象格式化成一个字符串
            e.g. String.Format("On {0:D}, {1} is {2:E} years old.", new DateTime(2012,4,22,14,35,5),"Aidan",9)
        3. 提供定制格式化器
    5. 解析字符串来获取对象： Parse
    6. 编码：字符和字节的相互转换
        1. 字符和字节流的编码和解码
        2. Base-64字符串的编码和解码
    7. 安全字符串 - System.Security.SecureString
        - 字符加密，性能一般
        - 实现了IDisposable接口
        - GC：非托管，回收后内容清0，不再存在于内容中

15. 枚举类型和位标志
    1. 枚举类型
    2. 位标志