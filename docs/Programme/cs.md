---
title: CLR via C#
layout: doc
date:   2023-04-09 15:20:00 +0800
categories: C#, CLR
---

# CLR via C#

## CLR基础

1. CLR的执行模型
	- 内存管理、加载、编译、安全、异常处理、线程同步
	- 编译：源代码文件->（JIT）编译器->托管模块（IL+元数据）
	- 流程：类库>程序集>托管模块（PE32+头 + CLR头 + IL + 源数据）
	- 通用类型系统CTS,Common Type System
		- 字段+方法+属性+事件
		- 封装：访问修饰符
	- 公共语言规范，CLS，Common Language Specification
	- 与非托管交互
		- 托管代码通过DLL调用非托管函数
		- 托管代码使用非托管COM（Component Object Model）组件（服务器）
		- 非托管代码可以使用托管类型（服务器）

2. .Net Framework --生成、打包、部署和管理应用程序及类型
	- windows应用存在的问题
		- dll hell：一个PE会依赖其他的dll
		- 安装：目录+注册表
		- 安全：悄悄下载
	- 将类型生成到模块中
		- 编译器参考程序集和响应文件将源代码生成PE
		- PE运行时查找响应文件加载程序集
	- 元数据=定义表+引用表+清单表
	- 将模块合并成程序集
		- 调用：CLR->程序集->文件
		- 程序集
			- 可重用（多编程语言实现）类型的基本单元
			- 使用版本号标记，可增量更新
			- 关联安全信息
				- 应用程序通过codeBase指定程序集
				- 将资源与数据文件单独划分
		- 不包含清单表的PE必须加载到另一程序集中使用
	- 程序集版本信息
	- 语言文化
	- 私有部署的程序集
		- PE基目录及子目录
		- 检查防篡改造成性能开销
	- 简单管理控制
		- XML配置文件

3. 共享程序集和强命名程序集
	- 部署与命名
		- 全局部署
			- 公认位置的程序集
	- 强命名程序集
		- 发布者签名，唯一标识
			- 文件名（不计扩展名）+版本号+语言文化+公钥
		- 防篡改
	- 全局程序集缓存，Global Assembly Cache，GAC
	- 延迟签名（delayed signing）/部分签名（partial signing）
		- 开发阶段使用公钥签名生成程序集，之后使CLR暂时信任不做哈希处理，但会失去保护
		- 打包部署使用私钥签名
	- 私有部署强命名程序集
	- 解析
		- 解析路线：CLR->MethodRef->IL->JIT编译->本机代码
		- 解析地址
			- 早期绑定：相同文件
			- 不同文件、相同程序集
			- 不同文件、不同程序集
	- 高级管理控制（配置）
		- 发布者策略控制

## 设计类型
4. 类型基础
	- Object
		- 最终基类
		- new
			- 创建
				- 计算类型及所有基类型定义字段所需要的字节数
				- 创建管理对象的额外成员
					- 类型对象指针 type object pointer
					- 同步块索引 sync block index
				- 初始化额外成员
				- 调用实例构造器
		- 类型转换
			- 里氏转换
			- 强转
				- is
				- as
		- namespace
		- 运行交互：栈+递归
			- 1个线程分配1MB的栈
			- prologue和epilogue

5. 基元类型、引用类型、值类型
	- 基元类型
		- glossary
			- 直接支持
			- 映射到Framework类库FCL
			- e.g.
				- int=System.Int32
		- 类型转换与溢出检查
			- checked和unchecked
			- CLR的数据转换IL指令
	- glossary
		- 内存必须congo托管堆分配
		- 堆上分配的每个对象必须有类型对象指针和同步索引块
		- 对象中的其他字节总是初始化为0
		- 从托管堆分配对象，内存不足时会强制执行垃圾回收
	- 值类型
		- 具有基元类型的行为，十分简单的类型
		- 无继承关系
		- 类型实例大小
			- 16字节以下
			- 16字节以上但不传参
		- 拆装箱
			- 装箱
				- 在托管堆中分配内存（递归内存+额外成员（类型对象指针+同步索引块））
				- 值类型字段复制到新分配的堆内存
				- 返回对象地址
			- 拆箱
				- 获取已装箱实例的未装箱部分的指针
				- 拆箱之后才紧接着进行内存复制
	- 值类型和引用类型
		- 区别
			- 表示形式：未装箱/已装箱
			- 父类
			- 初始值
			- 传参
			- 拷贝
			- 回收
				- 引用：垃圾回收
				- 值：方法不再活动即被释放
		- 比较：==和equal
		- GetHashcode
	- dynamic基元类型
		- 可用于局部遍历、字段和参数。
		- 在生成IL代码阶段才推断类型
		- dynamic和var的区别
			- var是语法糖，需要编辑器推断类型，并且不兼容表达式

6. 类型和成员基础
	- 成员
		- 常量、字段、实例构造器、类型构造器、方法、操作符重载、转换操作符、属性、事件、类型
	- 可见性
		- 友元程序集
			- [assembly:InternalVisibleTo["**********"]]Internal sealed class XXXType {...}
	- 静态类
		- 必须继承至Ststem.Object
		- 不能实现任何接口
		- 只能定义静态成员
		- 不能作为实例的变量使用
	- 分部类、结构和接口
		- 分部类
			- 源代码控制
			- 在同一个文件中将类或结构分解成不同的逻辑单元
			- 代码拆分
	- 组件、多态和版本控制
		- 组件软件编程，Component Software Programming， CSP
		- 组件的特点
			- .Net Framework：组件=程序集
			- 强命名
			- 程序集的代码永远不会静态链接到另一程序集中：.Net总是使用动态链接（组件永远维护自己的（强命名）标识）
			- 组件必须有引用元数据表
			- 组件必须指定他需要的安全权限
			- 组件要发布任何版本都不会改变的接口
		- 虚方法
			- Call/Callvirt 指令调用
		- 密封类

7. 常量和字段
	- 常量
		- 基元类型
		- C#：非基元类型的null
	- 字段
		- 类型字段的容纳数据需要的动态内存是在内存对象中分配的
		- 类型对象是在类型加载到一个AppDomain时创建的
		- 首次进行JIT编译时才将类型加载到一个AppDomain
		- readonly只能在构造器方法写入
			- 编译器和验证机制
			- 可利用反射修改
			- readonly引用类型时，不可改变的是引用，而不是引用的对象
		- 内联初始化：在代码中直接赋值来初始化，而不是将对构造器的调用写出来


8. 方法
	- 实例构造器和类（引用类型）
		- 在方法元数据表中始终叫.ctor
		- 禁止在构造器中调用虚方法，因为会执行派生类对虚方法的实现
		- 编译器在调用基类构造器前使用简化语法对所有字段进行初始化
	- 实例构造器和结构（值类型）
		- 结构不允许显式定义无参构造
		- 结构不能有实例字段初始值
		- 在控制返回到调用方之前，字段必须全部赋值
	- 类型构造器

9. 参数

10. 属性

11. 事件

12. 泛型
    1. 
    2. 
        1. 
        2. 
        3. 
        4. 代码爆炸
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 可验证性和约束
        约束：where
        无法重写类型参数
        1. 主要约束：0-1
        - class
        - struct
        2. 次要约束：0-？
        - 接口
        - 类型参数约束/裸类型约束：制定的类型实参要么就是约束的类型，要么就是约束的类型的派生类。
        3. 构造器约束：0-1
        4. 其他可验证问题
        - 泛型类型变量的转型
        - 将泛型类型变量设为默认值
            default(T)
        - 将泛型类型变量与null进行比较
        - 两个泛型类型遍历相互比较
        - 泛型类型变量作为操作数使用

13. 接口
    1. 类和接口继承
    2. 定义接口
    3. 继承接口
    4. 关于调用接口方法的更多讨论
    5. 隐式和显示接口方法实现
    6. 泛型接口
    7. 泛型和接口约束
    8. 实现多个具有相同方法名和签名的接口
    9. 用 显式接口方法(EIMI) 实现来增强编译时类型安全性
    10. 谨慎使用显示接口方法实现
    11. 设计：基类还是接口

## 基本类型
14. 字符、字符串和文本处理
    1. 字符
        - .NET Framework: 16bit Unicode
        - System.Char
    2. System.String  
        不可变（immutable）的顺序字符集，继承于Object
        1. 构造字符串
            - 基元类型
            - Idstr(load string)指令:CLR用一种特殊方式构造字面值String对象
            - unsafe
            - 转义机制
            - GC：
                - 字面值String在编译时连接，最终只有一个字符串放入模块元数据
                - 非字面值String使用 +操作符 ，连接时在运行时进行，在堆上创建多个String对象，需要垃圾会说，对性能有影响
            - 逐字字符串(verbatim string)：引号之间的所有字符会都被视为字符串的一部分
                - @
                - 通常用于制定文件和目录的路径
                - 与正则表达式搭配使用
        2. 字符串是不可变的
            - GC：
                - String类的字符串操作会在对上创建大量的String对象，造成更频繁的垃圾回收，从而影响性能。
                - StringBuilder,高效执行大量字符串操作
            - 不会发生线程同步问题
            - 字符串留用（string interning）：CLR可通过一个String对象共享多个完全一致的String内容，这样能减少系统中的自服从数量，从而节省内存
            - String和CLR紧密集成，出于对性能呢个考虑，String类是密封类
        3. 比较字符串 - 语言文化
        4. 字符串留用
            - 显式调用：String。Interrn
            - 标志
                - System.Runtime.CompilerServices.CompilationRelaxationsAttribute
                - System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning
            - CLR内部可能对某些字符串进行留用，但不要依赖于CLR的这个行为（CLR版本不同行为不同）
            - 字符串留用虽然有用，但留用本身操作需要花时间，所以使用必须谨慎
        5. 字符串池：编译器只在模块的元数据中的字面值字符串值写入一次。引用该字符串的所有代码都被修改成引用元数据中的统一字符串。
        6. 检查字符串中的字符和文本元素 -  StringInfo
        7. 其他字符串操作
    3. 高效率构造字符串 - StringBuilder
        1. 构造StringBuilder对象
            - 最大容量：Intel.MaxValue
            - 容量：默认16,动态扩容（倍增，复制到新数组，原始数组可以被垃圾回收）
            - 字符数组：
        2. StringBuilder的成员
            - 分配新对象的两种情况：
                - 动态构造字符串其长度超过了设置的容量
                - 调用ToString方法
            - 缺点：不方便、效率低
    4. 获取对象的字符串表示：ToString  
        定义类型时总应该重写ToString方法
        1. 制定具体的格式和语言文化
            - 实现System.IFormattable接口
            - 实现System.IFormatProvider接口
        2. 将多个对象格式化成一个字符串
            e.g. String.Format("On {0:D}, {1} is {2:E} years old.", new DateTime(2012,4,22,14,35,5),"Aidan",9)
        3. 提供定制格式化器
    5. 解析字符串来获取对象： Parse
    6. 编码：字符和字节的相互转换
        1. 字符和字节流的编码和解码
        2. Base-64字符串的编码和解码
    7. 安全字符串 - System.Security.SecureString
        - 字符加密，性能一般
        - 实现了IDisposable接口
        - GC：非托管，回收后内容清0，不再存在于内容中

15. 枚举类型和位标志
    1. 枚举类型
    2. 位标志
    3. 向枚举类型添加方法：扩展方法

16. 数组
    0. 引言
        - CLR支持一维、多维、交错数组。
        - System.Array
        - 引用类型
        - CLS要求所有数组必须是0基数组，但CLR确实支持非0基数组
        - 数组关联了额外开销信息：秩、每一维度的下限、每一维度的长度、数组的元素类型
        - 一维0基数组（SZ数组、向量）性能最佳：可以用一些特殊的IL指令处理
        - 0基以为交错数组的性能和普通向量一样好，不过，访问其元素必须进行两次或更多次的数组访问
        - CLR验证数组索引的有效性：JIT编译器旨在循环开始时检查一次数组边界，不会造成过大的性能损失
    1. 初始化数组
    2. 数组转型
        - Array.Copy()
            - 将元素从一个数组复制到另一个
            - 正确处理内存的层叠区域
            - 进行必要的类型转换
        - 数组协变性（array covariance）：有时确实需要数组congo一种类型转换为另一种类型        
        - 注意
            - System.Buffer.BlockCopy()
                - 只支持基元类型
                - 将按位兼容(bitwise-compatible)的数据从一个数组类型复制到另一个按位兼容的数据类型
            - System.Array.ConstrainedCopy()
                - 可靠地复制数组
                - 未完成复制则抛出异常，不会破坏目标数组中的数据
                - 允许方法在约束执行区(Constrained Execution Region, CER)中执行
                - 源数组和目标数组的元素类型必须相同或者时继承关系
                - 不执行任何装箱、拆箱或向下类型转换
    3. 所有数组的隐式派生自System.Array        
    4. 所有数组的隐式实现IEnumerable, ICollection和IList
    5. 数组的传递和返回
        - 数字作为实参传给方法时，实际传递的时对该数组的引用
        - Array.Copy()执行的是浅拷贝
    6. 创建下限非0的数组
        - Array.CreateInstance()
    7. 数组的内部工作原理
        - CLR内部实际支持两种不同的数组
            - SZ（single-dimensional, zero-based，一维0基、下限为0的一维）数组或向量(vector)
                - e.g. System.String[]
            - 下限未知的一维或多维数组
                - e.g. 
                    - 1基数组 System.String[*]
                    - 多维数组 System.String[,]
        - 访问SZ数组的速度比其他更快：
            - 对于SZ数组有一些特殊指令(newarr, ldelem, ldelema, ldlen, stelem)会导致JIT编辑其生成优化代码
            - for循环的测试表达式对数组的Length属性的调用
            - JIT编译器会生成代码在运行时循环之前进行索引上下限检查
            - CLR允许使用unsafe代码访问数组：在实际访问代码时关闭索引上下限检查
        - 不安全数据访问技术的三处不足：
            - 不易读写：需要fixed语句执行内存地址计算
            - 可能访问到不属于数组的内存：造成计算错误，损坏内存数据，破坏类型安全性，可能造成安全漏洞
            - CLR禁止在降低了安全级别的环境中允许不安全代码
    8. 不安全数组访问和固定大小的数组
        - 避免在堆上分配托管的数组对象：在线程栈上分配数组时通过C#的stackalloc语句完成的：
            - 分配一个内存块，这个内存块可以用不安全的指针来操纵。
            - 栈上分配的内存会在方法返回时自动释放：增强性能。
            - 要使用unsafe
        - 在结构中潜入数组需要满足以下几个条件：
            - 类型必须是结构（值类型）
            - 字段或其定义结构必须用unsafe关键字标记
            - 数组字段必须用fixed关键字标记
            - 数组必须是SZ数组
            - 数组的元素类型必须时基元类型

17. 委托
    1. 引言
        - 非托管C/C++回调函数不是类型安全的：非成员函数的地址知识一个内存地址，不携带任何额外的信息
    2. 用委托回调静态方法
        - 协变性covariance：方法能返回congo委托的返回类型派生的一个类型
        - 逆变性contravariance：方法获取的参数可以是委托的参数类型的基类
    3. 用委托返回实例方法
    4. 委托揭秘
        - 声明委托后，编译器会定义一个派生自FCL定义的System.MulticastDelegate类的一个完整的类
            - 包含构造器、Invoke、BeginInvoke（异步）、EndInvoke（异步）方法
            - 最重要的三个非公共字段：
                - _target:System.Object，静态回调返回null，实例回调返回方法要操作的对象
                - _methodPtr:System.IntPtr，CLR用来标识要回调的方法的整数值
                - _invocationList:System.Object，构造委托链时引用的委托数组